package org.aksw.simba.bengal.selector;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.rdf.model.Statement;

/**
 * Simple triple selector that selects statements based on a random path.
 * 
 * @author Michael R&ouml;der (roeder@informatik.uni-leipzig.de)
 *
 */
public class PathBasedTripleSelector extends AbstractSelector {

    private Set<String> sourceClasses;
    private Set<String> targetClasses;
    private String endpoint;
    private String graph;
    private List<Resource> resources;
    private Random r = new Random(20);
    private int minSize = 1;
    private int maxSize = 5;
    private boolean useSymmetricCbd = false;

    /**
     * Constructor
     * 
     * @param sourceClasses
     *            Classes for subjects
     * @param targetClasses
     *            Classes for objects
     * @param endpoint
     *            SPARQL endpoint
     * @param graph
     *            Graph to query (null if none)
     * @param minSize
     *            Minimal size of summary
     * @param maxSize
     *            Maximal size of summary
     */
    public PathBasedTripleSelector(Set<String> sourceClasses, Set<String> targetClasses, String endpoint, String graph,
            int minSize, int maxSize, long seed, boolean useSymmetricCbd) {
        this.sourceClasses = sourceClasses;
        this.targetClasses = targetClasses;
        this.endpoint = endpoint;
        this.graph = graph;
        resources = null;
        this.minSize = minSize;
        if (maxSize < minSize) {
            maxSize = minSize + 1;
        }
        this.maxSize = maxSize;
        this.useSymmetricCbd = useSymmetricCbd;
        this.r = new Random(seed);
    }

    /**
     * Constructor
     * 
     * @param sourceClasses
     *            Classes for subjects
     * @param targetClasses
     *            Classes for objects
     * @param endpoint
     *            SPARQL endpoint
     * @param graph
     *            Graph to query (null if none)
     */
    public PathBasedTripleSelector(Set<String> sourceClasses, Set<String> targetClasses, String endpoint,
            String graph) {
        this.sourceClasses = sourceClasses;
        this.targetClasses = targetClasses;
        this.endpoint = endpoint;
        this.graph = graph;
        resources = null;
    }

    /**
     * Returns the next set of statements generated by this selector
     * 
     * @return Set of statements
     */
    public List<Statement> getNextStatements() {
        if (resources == null) {
            resources = getResources(sourceClasses, endpoint, graph);
        }
        // pick a random length for the path
        int size = minSize + r.nextInt(maxSize - minSize + 1);
        List<Statement> result = new ArrayList<>();
        Set<Resource> visitedResources = new HashSet<Resource>();

        // Choose the first resource randomly
        int counter = Math.abs(r.nextInt() % resources.size());
        Resource currentResource = resources.get(counter);
        visitedResources.add(currentResource);

        List<Statement> statements = null;
        Statement statement;
        boolean resourceChanged = true;
        while (result.size() < size) {
            // get symmetric CBD
            if (resourceChanged) {
                statements = getSummary(currentResource);
                if (statements.size() == 0) {
                    return result;
                }
                resourceChanged = false;
            }

            // now pick a random statement
            counter = Math.abs(r.nextInt() % statements.size());
            statement = statements.get(counter);
            // if this is the last statement of this path
            if (result.size() == (size - 1)) {
                result.add(statement);
            } else {
                // we have to make sure that the object is a resource that we
                // have not seen before
                if (statement.getObject().isResource()
                        && (!visitedResources.contains(statement.getObject().asResource()))) {
                    result.add(statement);
                    currentResource = statement.getObject().asResource();
                    visitedResources.add(currentResource);
                    resourceChanged = true;
                }
            }
        }
        System.out.println(result);
        return result;
    }

    /**
     * Gets a set of statements that summarize a resource r
     * 
     * @param r
     *            A resource
     * @return Summary (some CBD)
     */
    public List<Statement> getSummary(Resource r) {
        // one can use symmetric cbds here as well
        if (useSymmetricCbd) {
            return getSymmetricCBD(r, targetClasses, endpoint, graph);
        } else {
            return getCBD(r, targetClasses, endpoint, graph);
        }
    }

    public static void main(String args[]) {
        Set<String> classes = new HashSet<>();
        classes.add("<http://dbpedia.org/ontology/Person>");
        classes.add("<http://dbpedia.org/ontology/Place>");
        classes.add("<http://dbpedia.org/ontology/Organisation>");
        SimpleSummarySelector sss = new SimpleSummarySelector(classes, classes, "http://dbpedia.org/sparql", null);
        sss.getNextStatements();
        sss.getNextStatements();
    }
}
